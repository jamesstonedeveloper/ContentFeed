# ContentFeed
 
An app that lets you create a post (title and body of text) and displays a list of all posts made in the app by all users. Posts are stored in Firebase Firestore and a SnapshotListener is used to get real-time updates to the list of posts. This list is then saved locally to Realm so you can see them offline, and they are read from Realm with a RealmChangeListener. If the API call to get the posts fails you will be prompted to retry the call. You can also swipe the page to call again. When creating a post you will be prompted to enter a title and content if you haven't, and will be notified if there isn't an internet connection. 

## Testing
As I don't yet know unit testing I used a few manual methods depending on what feature I was testing.

For the list of posts I used dummy data in the repository to test that the data would be read and shown correctly. This was simply done by creating a list of the desired objects and passing them back. Using a for loop allows me to test any number of objects to display. The commit shows 10, but testing went up to 1000. See this commit https://github.com/jamesstonedeveloper/ContentFeed/commit/c8b4413d050fe7111f9b74c2e81b95458699da50

After the UI was confirmed to be working I tested changing the dummy data for real data and reading directly from realm. I changed the previous for loop to write the dummy object to Realm. Then I removed that loop and replaced it with reading from Realm. I added the RealmChangeListener and ran the app to see if it would read from Realm correctly. It did, but if it didn't I would set up breakpoints at the key lines to see where it was going wrong. I'd also check the realm file itself to make sure the objects had been written correctly. See this commit https://github.com/jamesstonedeveloper/ContentFeed/commit/2a59b83672b5b378948119dd0b649573c0c72546

For small things such as checking the title or content being posted wasn't empty or null I'd just manually test that myself, do my best to break it. As expected of small checks, there weren't any problems.

Uploading to the Firestore simply consisted of checking the database after uploading an object and making sure the values were correct and that the object was being stored in the correct location.

Retrieving objects from the Firestore was as simple as making sure the correct number of objects were being returned and that the values of them were correct. As Firestore has mapping for custom objects this went smoothly.

## Issues/problems faced
I wanted to use Firebase Functions in this project as a little something extra, but after successfully integrating a function I realised I was vastly over-engineering something incredibly simple, and therefore decided to take it out. It was a function that assigned an ID value to a new post. The ID would be an incremental value, ensuring that every post had a unique ID and was in order of creation. This caused multiple issues, mostly because Firebase Functions can take up to 10 seconds to trigger. This meant that if the object was read from the server in this time then it wouldn't have an ID and couldn't be stored safely or ordered correctly in the displayed list. It also opened up the possibility of one post uploaded after another but being given an ID first. After a while I decided it was far easier to give each new object a random UUID before uploading and also give it a createdAt timestamp, ensuring every object had a unique ID and could be sorted by time created properly.

The other major issue I faced was a bug where data from the server wasn't displayed until you left the feed page and came back to it or you swiped to refresh the page. Local data was being displayed, but no new posts would be until you triggered it again. Breakpoints in the API call confirmed that all the posts from the server were correctly being fetched and written to Realm, so I had to figure out why they weren't being read. The RealmChangeListener was only being called once and returned 0 items, so I initially thought that the listener was being removed at the wrong time somewhere or that multiple listeners were attached and that was causing problems. I streamlined it so the listener was only ever being attached once, only ever removed if it was being reattached or if the ViewModel was cleared, but the bug persisted. The bug wasn't present when using breakpoints, so I knew it was a timing issue. After using logs to track the order of things I realised the listener was being attached before the API call, but it would miss the timing for when the API call received the objects and therefore wouldn't trigger. This was fixed by attaching the listener after the API call

## Future improvements
I'd like to replace the use of LiveData with RxJava as it would add more flexibility and look a lot cleaner. The reactive nature of the app so far is very basic so Rx isn't needed, but it shouldn't take long to swap out and would allow for far more powerful functions in the future.
If the app were to have more pages I'd like to use custom view components for heavily reusable components such as buttons and text input layouts. If I had more time I'd also like to implement bindable adapters to the input layouts to warn the user if they haven't entered a title or content before trying to submit the new post. Ideally the user shouldn't have to wait until they try to post to find there's something wrong such as they've missed the title or have no internet connection.
